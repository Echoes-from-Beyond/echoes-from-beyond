import com.diffplug.spotless.LineEnding
import org.echoesfrombeyond.gradle.task.GeneratePackageInfo
import org.echoesfrombeyond.gradle.task.GeneratePackageTree
import kotlin.math.min

plugins {
    id("java")

    // Plugin versions in precompiled scripts are determined by buildSrc/build.gradle.kts.
    id("com.diffplug.spotless")
}

repositories {
    mavenCentral()
}

dependencies {
    // We have to use the String APIs of versionCatalogs here because of Gradle quirks.
    val libs = versionCatalogs.named("libs")

    compileOnly(libs.findBundle("compileOnly").get())

    implementation(libs.findBundle("implementation").get())
    runtimeOnly(libs.findBundle("runtimeOnly").get())

    testImplementation(libs.findBundle("testImplementation").get())
    testRuntimeOnly(libs.findBundle("testRuntimeOnly").get())
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(25)
    }

    withSourcesJar()
    withJavadocJar()
}

tasks.test {
    maxParallelForks = min(Runtime.getRuntime().availableProcessors() - 1, 1)
    useJUnitPlatform()
}

tasks.javadoc {
    val core = options as? CoreJavadocOptions
    core?.addBooleanOption("Xdoclint:all,-missing", true)
}

tasks.withType<Jar>().configureEach {
    from(rootProject.layout.projectDirectory.file("LICENSE")) {
        into("META-INF")
    }
}

tasks.withType<JavaCompile>().configureEach {
    options.encoding = "UTF-8"
}

tasks.withType<Javadoc>().configureEach {
    options.encoding = "UTF-8"
}

spotless {
    // This is currently necessary to prevent Gradle config cache invalidation:
    // https://github.com/gradle/gradle/issues/25469#issuecomment-3444231151. Also make sure that
    // any files formatted by Spotless are using LF.
    lineEndings = LineEnding.UNIX

    // This is the default, but it's nice to be explicit.
    encoding = Charsets.UTF_8

    java {
        target(sourceSets.main.map { set -> set.allJava.sourceDirectories })

        // Always clean these up first.
        removeUnusedImports()

        // Order useful imports according to the outline below.
        //
        // - Non-static imports:
        //   - Anything in `java` or `javax`
        //   - Everything else that isn't specified
        //   - Anything in `org.echoesfrombeyond`
        // - Static imports:
        //   - Anything in `java` or `javax`
        //   - Everything else that isn't specified
        //   - Anything in `org.echoesfrombeyond`
        importOrder(
            "java|javax",
            "",
            "org.echoesfrombeyond",
            "\\#java\\#javax",
            "\\#",
            "\\#org.echoesfrombeyond"
        )

        googleJavaFormat("1.33.0")
            .reflowLongStrings()

            // We already reordered imports according to our own scheme, so disable Google's import
            // reordering.
            .reorderImports(false)

        formatAnnotations()
        licenseHeaderFile(rootProject.layout.projectDirectory.file("LICENSE_HEADER"))
    }
}

val generatePackageInfoDir: Provider<Directory> = project.layout.buildDirectory.map { buildDir ->
    buildDir.dir("generatePackageInfo")
}

val generatePackageInfoSrcDir: Provider<Directory> = generatePackageInfoDir.map { dir ->
    dir.dir("src/main/java")
}

sourceSets {
    // Creating a source set here makes it so that static analysis tools can pick up on e.g.
    // nullability annotations in the generated code.
    val generated = create("generatedPackageInfo") {
        java {
            setSrcDirs(listOf(generatePackageInfoSrcDir))
        }
    }

    // We want the generated sources to be able to reference anything `main` can. Ensure the
    // classpath is the same, and also allow `main` to reference the generated code.
    main {
        generated.compileClasspath = compileClasspath

        val generatedOutput = generated.output
        output.dir(generatedOutput)

        compileClasspath += generatedOutput
        runtimeClasspath += generatedOutput
    }
}

val generatePackageTree = tasks.register<GeneratePackageTree>("generatePackageTree") {
    sourceDirectories.set(sourceSets.main.map { set -> set.java.sourceDirectories })
    packagesFile.set(generatePackageInfoDir.map { dir -> dir.file("packages") })
}

val generatePackageInfo = tasks.register<GeneratePackageInfo>("generatePackageInfo") {
    generatedSourceDirectory.set(generatePackageInfoSrcDir)
    packagesFile.set(generatePackageTree.flatMap { t -> t.packagesFile })
    packageInfoGenerator.set { packageName ->
        "/* AUTOGENERATED, DO NOT EDIT */ " +
                "@org.jetbrains.annotations.NotNullByDefault " +
                "package $packageName;"
    }
}

tasks.named("compileGeneratedPackageInfoJava").configure {
    inputs.files(generatePackageInfo)
}