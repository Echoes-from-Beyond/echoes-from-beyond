# CodecHelper

This library plugin is intended to reduce a lot of the boilerplate associated with constructing `BuilderCodec`s. It features an annotation-based API and uses reflection to introspect types.

## Add this library to your project

The plugin is available on Maven Central. To add it as a dependency with Kotlin Gradle:

```kotlin
repositories {
    mavenCentral()
}

dependencies {
    compileOnly("org.echoesfrombeyond:codec-helper:0.2.0")
}
```

Then, in your plugin's `manifest.json`, add the following entry to the `DependsOn` block:
```
"org.echoesfrombeyond:CodecHelper": "^0.2.0"
```

## Basic usage

This section covers the simplest usage of the API.

### Simple example

The main entrypoint of this library is the `CodecUtil.modelBuilder` static function, which is overloaded several times. Consult the Javadoc for details.

The main purpose of `modelBuilder` is to generate a `BuilderCodec` from an arbitrary class, skipping a lot of the boilerplate associated with using Hytale's builder API. For example, the following code, using CodecHelper:

```java
// To generate a BuilderCodec, classes must be annotated with @ModelBuilder
@ModelBuilder
public class DataClass {
  // Generate a codec for this class, using the shared resolver.
  public static final BuilderCodec<DataClass> CODEC = CodecUtil.modelBuilder(DataClass.class, Plugin.getSharedResolver());

  // All non-static, non-final fields will automatically be (de)serialized by the generated codec...

  @Doc("Specify field documentation with the Doc annotation.")
  private int IntegerValue;

  @Doc("This is a string field.")
  private String StringValue;

  @Doc("This is a map field.")
  private Map<String, Integer> StringToIntMap;

  // ...however, this field will be ignored because of the Skip annotation.
  @Skip
  private String Ignored;
}
```

Is equivalent to the "traditional" builder API:

```java
public class DataClass {
  public static final BuilderCodec<DataClass> CODEC = BuilderCodec.builder(DataClass.class, DataClass::new)
      .append(new KeyedCodec<>("IntegerValue", Codec.INTEGER), (self, value) -> self.IntegerValue = value, (self) -> self.IntegerValue)
      .documentation("Specify field documentation with the Doc annotation.")
      .add()
      .append(new KeyedCodec<>("StringValue", Codec.STRING), (self, value) -> self.StringValue = value, (self) -> self.StringValue)
      .documentation("This is a string field.")
      .add()
      .append(new KeyedCodec<>("StringToIntMap", new MapCodec<>(Codec.INTEGER, HashMap::new)), (self, value) -> self.StringToIntMap = value, (self) -> self.StringToIntMap)
      .documentation("This is a map field.")
      .add()
      .build();

  private int IntegerValue;
  private String StringValue;
  private Map<String, Integer> StringToIntMap;
  
  private String Ignored;
}
```

Either of these could serialize to the following JSON:

```json
{
  "IntegerValue": 10,
  "StringValue": "This is a string",
  "StringToIntMap": {
    "FirstKey": 10,
    "SecondKey": 11,
    "ThirdKey": 12
  }
}
```

You can also generate `AssetBuilderCodec`:

```java
@ModelBuilder
public class MyAsset implements JsonAsset<String> {
  public static final AssetBuilderCodec<String, MyAsset> CODEC = CodecUtil.modelAssetBuilder(MyAsset.class, Plugin.getSharedResolver());
  
  @Id private String Identifier;
  @Data private AssetExtraInfo.Data Extra;
  
  private String SomeValue;
  private Integer SomeOtherValue;
  
  @Override
  public String getId() {
    return Identifier;
  }
}
```

In addition to the class for which to generate a codec, `modelBuilder` also requires a `CodecResolver`. This is simply a functional interface whose only method accepts a `Type` and a `Field`, and returns a `Codec` if it is able to determine how the field should be (de)serialized; and if not, returns `null`.  

The same resolver can be passed to `modelBuilder` any number of times. Resolvers should generally be stored in `static`s and reused as much as possible.

The default codec resolver, which is fully-featured, can be accessed simply by calling `Plugin.getSharedResolver()`. Consult the Javadoc on that method for more details about its capabilities. 

Otherwise, resolvers with custom capabilities can be created using the builder method `CodecResolver.builder()`. A resolver that is only capable of handling primitive/wrapper types along with String is found at `CodecResolver.PRIMITIVE`.

Although codecs generated by this library are very efficient, codec resolution itself is (relatively) costly since the process requires a lot of type introspection. To alleviate this performance cost in cases where the same type must be resolved multiple times, provide a `CodecCache` to the `modelBuilder` function. A `CodecCache` instance meant to be shared across multiple plugins can be obtained by calling `Plugin.getSharedCache()`, or a fresh instance can be constructed with `CodecCache.cache()`. Another potential technique to improve performance is to only use resolvers with the minimum required capabilities to resolve your data types. For example, a data class that only contains primitive types can use `CodecResolver.PRIMITIVE` and nothing else.

### Name overriding

By default, the name of a generated field in the serialized data is the same as the name of the field in the code. This behavior can be overridden with the `@Name` annotation:

```java
@ModelBuilder
public class Data {
  @Name("IntegerField")
  public int value;
}
```

The above could serialize to the following JSON:

```json
{
  "IntegerField": 10
}
```

### Ignoring fields

Fields can be ignored as follows:

```java
@ModelBuilder
public class Data {
  @Skip
  public Object doNotSerialize;
}
```

Even if such fields are present in the data, they will not be written to during deserialization. `@Skip` is roughly analogous to the `transient` modifier.

### Documenting fields

Both fields and `@ModelBuilder` classes can be documented:

```java
@ModelBuilder
@Doc("This is data type documentation.")
public class Data {
  @Doc("This is field documentation.")
  public String StringField;
}
```

### "Nested" @ModelBuilder resolution

If the resolver supports it (see `CodecResolver.Builder.withRecursiveResolution()`), nested types are automatically resolved as one might expect.

```java
@ModelBuilder
public class Inner {
  public String InnerValue;
}

@ModelBuilder
public class Outer {
  public Inner Inner;
  public String OuterValue;
}
```
```json
{
  "Inner": {
    "InnerValue": "This is the inner value!"
  },
  "OuterValue": "This is the outer value!"
}
```

## Advanced usage

CodecHelper supports a significant degree of customization, mostly via the `CodecResolver` interface and builder API.

### Using custom resolvers alongside built-in ones

Any number of custom resolvers can be added using the `chain` method on `CodecResolver.Builder`.

```
CodecResolver.builder()
  // You almost always want to chain this first!
  // Without it the resolver couldn't resolve even the most basic types.
  .chain(CodecResolver.PRIMITIVE)
  .chain(yourCustomResolverHere)
  .withArraySupport()
  .build();
```

When the resulting resolver is queried to produce a codec, resolvers will be executed in the order that `chain` was called. The first resolver that returns a non-null value will supply the value for the whole resolver; resolvers appearing after the one that returned non-null will not be queried.

Adding built-in support for certain types necessitates adding "internal" resolvers. Such internal resolvers will always execute _after_ any that are added by calling `chain`, though their order is otherwise unspecified.

### Subtype resolution

Some types, such as `List<T>`, cannot be resolved even if the resolver builder specified `withCollectionSupport()`. This is because the internal collection resolver expects _concrete_ implementations, and it cannot construct abstract classes or interfaces. To solve this, it is required to add a "subtype mapping":

```
CodecResolver.builder()
  .chain(CodecResolver.PRIMITIVE)
  .withCollectionSupport()
  .withSubtypeMapping(List.class, ArrayList.class)
  .build();
```

If no other resolver for a type can be found, the subtype resolver will attempt to find a valid subtype mapping and resolve that type instead.

For example, if the resolver above encounters a `List<String>`, the subtype resolver will attempt to recursively resolve `ArrayList<String>`. `ArrayList` is non-abstract and has a public parameterless constructor, so the collection resolver knows how to handle it.

Subtype resolution is capable of determining the subtype even in cases where no direct mapping exists. For example, if the resolver above encountered a `Collection<String>` instead, it would still attempt to recursively resolve `ArrayList<String>`. This is possible because the "key" type in the mapping, `List`, is _itself_ a subtype of `Collection`, and thus any subtype it is mapped to would necessarily be valid for `Collection` too.

If there are multiple possible mappings, the closest type in terms of inheritance depth is preferred. For example, if `withSubtypeMapping(Collection.class, HashSet.class)` was specified, and the resolver encountered a `Collection`, it would attempt to recursively resolve `HashSet` instead, because `Collection` is closer to itself than it is to `List`.

### Validator annotations

It's possible to specify "validator annotations", that are used to interop with Hytale's `Validator` API.

```java
@ModelBuilder
public class Data {
  // Ranges are always inclusive unless otherwise specified
  // See org.echoesfrombeyond.codec.annotation.validator for other built-in validators

  @ValidateIntRange(min = 0, max = 10)
  public int IntValue;

  @ValidateLengthRange(min = 10, max = 15)
  public String StringValue;
}
```

In addition to the built-in annotations, it is possible to construct user-defined annotations that produce custom validators.

```java
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@ValidatorSpec(CustomProvider.class) // must reference a ValidatorProvider
@Documented
public @interface ValidateCustom {
}
```

```java
public class CustomProvider implements ValidatorProvider<ValidateCustom> {
  // A field named INSTANCE of type ValidatorProvider MUST exist! 
  // It is accessed reflectively during resolution!
  public static final CustomProvider INSTANCE = new CustomProvider();
  
  private CustomProvider() {}
  
  @Override
  public @Nullable Validator<?> getInstance(ValidateCustom args, Field field) {
    // Return the custom validator here.
    // Implementations must ensure that the validator can validate values of the field type!
    // If the field type is not compatible, return `null` to raise an error during resolution.
    return null;
  }
}
```

Given the examples above, any fields annotated with `@ValidateCustom` will use the `Validator` returned by `getInstance`. Each field can have multiple such annotations.

### Inherit from existing codecs

Consider the following two classes.

```java
public abstract class SuperClass {
  public static final BuilderCodec<SuperClass> CODEC = CodecUtil.modelBuilder(SuperClass.class, Plugin.getSharedResolver());
  
  private String SuperStringValue;
  private int SuperIntValue;
}
```

```java
public class BaseClass extends SuperClass {
  public static final BuilderCodec<Superclass> CODEC = CodecUtil.modelBuilder(BaseClass.class, SuperClass.CODEC, Plugin.getSharedResolver());
  
  private String BaseStringValue;
}
```

`BaseClass` could serialize to the following JSON:

```json
{
  "SuperStringValue": "Super String Value",
  "SuperIntValue": 67,
  "BaseStringValue": "Base String Value"
}
```

Note that, because `SuperClass` is `abstract`, it can only be serialized through non-`abstract` subclasses that provide their own codecs.