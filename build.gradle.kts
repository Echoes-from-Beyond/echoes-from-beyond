plugins {
    id("java")

    // Code formatting plugin.
    id("com.diffplug.spotless") version "8.1.0"
}

group = "org.echoesfrombeyond"
version = "1.0-SNAPSHOT"

repositories {
    mavenCentral()
}

dependencies {
    compileOnly("org.jetbrains:annotations:26.0.2-1")

    testImplementation("org.junit.jupiter:junit-jupiter:5.7.1")
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(25)
    }
}

tasks.test {
    useJUnitPlatform()
}

spotless {
    json {
        target("src/main/*.json", "src/test/*.json")
        gson()
            .version("2.13.1")
            .indentWithSpaces(2)

            // Sort by JSON keys. This might cause things to break, but can be turned
            // off easily without causing formatting churn.
            .sortByKeys()
    }
    java {
        target(sourceSets.main.get().java, sourceSets.test.get().java)

        // Always clean these up first.
        removeUnusedImports()

        // Order useful imports according to the outline below.
        //
        // - Non-static imports:
        //   - Anything in `java` or `javax`
        //   - Everything else that isn't specified
        //   - Anything in `org.echoesfrombeyond`
        // - Static imports:
        //   - Anything in `java` or `javax`
        //   - Everything else that isn't specified
        //   - Anything in `org.echoesfrombeyond`
        importOrder(
            "java|javax",
            "",
            "org.echoesfrombeyond",
            "\\#java\\#javax",
            "\\#",
            "\\#org.echoesfrombeyond"
        )

        // Use Eclipse JDT to reorder members. This helps to reduce the risk of merge
        // conflicts.
        eclipse()
            .sortMembersEnabled(true)
            .sortMembersVisibilityOrderEnabled(true)
            .sortMembersDoNotSortFields(true)

            // T = (nested) types, SF = static fields, SI = static initializers,
            // F = fields, I = initializers, C = constructors, SM = static methods,
            // M = methods
            .sortMembersOrder("T,SF,SI,F,I,C,SM,M")

            // V = private, R = protected, D = package-private, B = public
            .sortMembersVisibilityOrder("V,R,D,B")

        googleJavaFormat("1.33.0")
            .reflowLongStrings()

            // We already reordered imports according to our own scheme, so disable
            // Google's import reordering.
            .reorderImports(false)

        formatAnnotations()
        licenseHeaderFile("LICENSE_HEADER")
    }
}

sourceSets {
    create("generatedPackageInfo") {
        java {
            srcDir("src/generatedPackageInfo/java")
        }

        compileClasspath = sourceSets.main.get().compileClasspath
    }
}

tasks.getByName("build").dependsOn("generatePackageInfo")

tasks.register("generatePackageInfo") {
    group = "other"
    description = "Generates package-info.java files corresponding to the package tree."

    inputs.files({ sourceSets.main.get().java.sourceDirectories })
    inputs.property("generatedSourceDirs", {
        sourceSets.getByName("generatedPackageInfo").java.srcDirs
    })

    outputs.dirs({
        @Suppress("PLATFORM_CLASS_MAPPED_TO_KOTLIN", "UNCHECKED_CAST")
        val outSourceDirs = inputs.properties["generatedSourceDirs"] as java.util.Set<File>

        outSourceDirs.flatMap { outDirectory ->
            sourceSets.main.get().java.srcDirs.flatMap { sourceDirectory ->
                sourceDirectory.walkTopDown().filter(File::isDirectory).filter { dir ->
                    dir.walkTopDown().maxDepth(1).filter(File::isFile).any { file ->
                        file.extension == "java"
                    }
                }.map { file -> outDirectory.resolve(file.relativeTo(sourceDirectory)) }
            }
        }
    })

    doLast {
        val fileSet = outputs.files.files

        @Suppress("PLATFORM_CLASS_MAPPED_TO_KOTLIN", "UNCHECKED_CAST")
        val outSourceDirs = inputs.properties["generatedSourceDirs"] as java.util.Set<File>

        outSourceDirs.forEach { outSourceDir ->
            outSourceDir.walkBottomUp().filter(File::isDirectory).filter { file ->
                fileSet.none { set -> set.startsWith(file) }
            }.forEach { file -> file.deleteRecursively() }

            fileSet.filter { file -> file.startsWith(outSourceDir)  }
                .map { file -> Pair(file, file.relativeTo(outSourceDir).path) }
                .map { (file, path) -> Pair(file, path.replace('/', '.')) }
                .forEach { (file, pack) ->
                    val packageInfo = file.resolve("package-info.java")
                    packageInfo.writeText("/* AUTOGENERATED, do not edit */ " +
                            "@org.jetbrains.annotations.NotNullByDefault " +
                            "package $pack;", Charsets.UTF_8)
                }
        }
    }
}